## 函数增长
* 上界函数
  $$ 0 \leq f(n) \leq cg(n)$$
  $$ f(n) = O(g(n))$$
* 下界函数
  $$ cg(n) \leq f(n) $$
  $$ f(n) = \Omega(g(n)) $$
* 渐进紧确界函数
  * $$ c_{1}|g(n)| \leq |f(n)| \leq c_{2}|g(n)| $$
  * $$ 即f(n) = \Theta(g(n))  $$
* 时间复杂度
  * 多项式时间：可用多项式函数对计算时间界限的算法
    $$ \Omicron(1) < \Omicron(logn)<\Omicron(nlogn)< \Omicron(n^{2})<\Omicron(n^{3})$$
  * 指数时间：计算时间用指数函数界限的算法
    $$ \Omicron(2^{n}) < \Omicron(n!) < \Omicron(n^{n})$$

## 分治法
### 基本思想
* 将原本的问题分为几个规模较小的，但类似的原问题的子问题，递归地求解这些子问题，再合并。
* 分解，解决，合并
### 例子
* 归并排序
  * $$ T(n) = 2T(n/2) + cn = \Omicron(nlogn) $$
* 最近点对
  * 小于等于三个元素时，比较得出最小的点对
  * 大于等于三时，先二分，然后再划定最小区间，在区间内更新最小值
  * $$ T(n) = 2T(n/2) + nlog^2n $$

* 最大子数组问题
  * 交叉的情况：从中间向两边扩散
  * 不交叉，递归求解
  * $$ T(n) = \Theta(nlgn)$$
* 矩阵
### 求递归式
* 代换法
  *  看递归式猜测解
  *  代入用数学归纳法证明
  * $$ 如：T(n) = 2T([n/2])+n
     \\ 猜测其解为\Omicron(nlogn)
     \\ 代入
     \\ T(n) \leq 2(c[n/2]log([n/2])) + n
     \\ \leq cnlog(n/2) +n
     \\ = cnlogn -cnlog2 +n
     \\ = cnlogn -(c-1)n
    
    $$
* 递归树法
  * 画出递归树，求节点，总代价即为节点的代价和

* 主方法
  * $$ T(n) = aT(n/b)+f(n)
  \\ 如果 \epsilon > 0 f(n) = \Omicron(n^{log_{b}a-\epsilon}) 则T(n)=\Theta(n^{log_{b}a})
  \\ 若 f(n) = \Theta(n^{log_{b}a}) 则T(n)  = \Theta(n^{log_{b}a}logn)
  \\ 若 \epsilon > 0 有 f(n) = \Omega(n^{log_{b}a}logn),同时 af(n/b) \leq cf(n),则T(n) = \Theta(f(n))
  $$ 
## 概率分析

## 中位数和顺序统计
### 概念
*第i个顺序统计量是该集合中第i小的元素
* 中位数
  * odd: i= (n+1)/2
  * oven: ave([(n+1)/2]+[(n+1)/2+1])
### 选择第k小元素
* 排序
* 选择
    * quicksort_partition函数
    * 步步紧逼
### 最大值和最小值
* 遍历即可

### 中位数问题
* 一维的中位数问题
* 带权中位数问题

## 动态规划
### 例子
* 切钢条
  $$ p[n]_{0 \leq i \leq n} = p[i]+p[n-i]$$
* 矩阵链相乘
* 长度从 2 到n逐渐变大
  $$ f(x)= \left\{
      \begin{aligned}
          0 && i==j
        \\ min_{i \leq k < j}\{m[i,k]+m[k+1,j]+p_{i-1}p_{k}p_{j}\}
      \end{aligned}
      \right.$$
* 最优二叉搜索树
  * 区间递增
  * $$ e[i,i-1] = q_{i-1}
   \\  \omega[i,i-1] = q_{i-1}$$
  * $$ e[i,r-1] + e[r+1,j] + \omega[i,j] $$
* 字符串拆分
  * 长度区间递增
  * $$ cost[i,j] = min_{i< k < j}\{L[j] - L[i] +cost[i,k]+cost[k,j]\}$$
## 贪心算法
### 概念
* 每一步仅作出当时看起来最佳的选择，即局部最优的选择。
* 个人理解：对于当前这一步，只做两种选择，要或者不要。
### 实例
* 活动选择
  * 每次选择最早结束时间的活动加入集合A
* 0/1 背包问题

## 单源最短路径
### Floyd算法
*  $$ 遍历 V-1次 $$
* 按顺序松弛每一条边
### Floyd例子
* 套利交易
  * 松弛边操作至关重要
  * 要根据条件松弛边
## 所有节点对的最短路径问题

## 概念
* 算法的基本概念和性质。
  > 算法就是任何良定义（well-defined）的计算过程，该过程取某个值或值的集合作为输入（input），并产生某个值或者值的集合作为输出（output）。
   算法是一组有穷的规则，它规定了解决某一特定类型问题的一系列运算。
* 渐进表示


